<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Soda Pop Bubbles</title>
<style>
  html, body { height:100%; margin:0; background:#0b0f14; overflow:hidden; touch-action:none; }
  canvas { display:block; width:100vw; height:100vh; }
  .hud {
    position:fixed; left:8px; bottom:8px; padding:4px 8px;
    font:10px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    color:#a0b3c6; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    border-radius:6px; user-select:none; pointer-events:none;
  }
  .hud b { color:#e6f4ff }
  @media (min-width: 600px) {
    .hud { 
      left:12px; bottom:12px; padding:6px 10px; 
      font-size:12px; line-height:1.3; border-radius:8px;
    }
  }
  
  .help-btn {
    position:fixed; top:8px; right:8px; width:28px; height:28px;
    background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2);
    border-radius:50%; cursor:pointer; display:flex; align-items:center; justify-content:center;
    font:bold 12px system-ui; color:white; user-select:none;
    transition:background 0.2s ease;
  }
  .help-btn:hover { background:rgba(255,255,255,0.2); }
  @media (min-width: 600px) {
    .help-btn { top:12px; right:12px; width:32px; height:32px; font-size:14px; }
  }
  
  .modal {
    position:fixed; top:0; left:0; width:100vw; height:100vh;
    background:rgba(0,0,0,0.7); display:none; align-items:flex-start; justify-content:center;
    z-index:1000; overflow-y:auto; padding:20px 0;
  }
  .modal.show { display:flex; }
  
  .modal-content {
    max-width:500px; width:calc(100vw - 40px); margin:0 20px; padding:20px;
    background:#1a1f2b; border:1px solid #2a3441; border-radius:12px; 
    color:#e6f4ff; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    box-shadow:0 20px 40px rgba(0,0,0,0.5); max-height:calc(100vh - 80px); overflow-y:auto;
  }
  
  @media (min-width: 600px) {
    .modal { align-items:center; padding:40px 0; }
    .modal-content { 
      font-size:16px; line-height:1.5; padding:30px; 
      width:auto; margin:20px; max-height:calc(100vh - 120px);
    }
  }
  .modal-content h2 {
    margin:0 0 15px 0; color:#90ee90; font-size:18px; font-weight:normal;
  }
  @media (min-width: 600px) {
    .modal-content h2 { font-size:20px; margin-bottom:20px; }
  }
  .modal-content ul {
    margin:0; padding-left:20px; color:#a0b3c6;
  }
  .modal-content li { margin:8px 0; }
  .modal-content p {
    margin:12px 0; color:#c0d0e0; font-style:italic;
  }
  @media (min-width: 600px) {
    .modal-content p { margin:15px 0; }
  }
  .learn-more-btn {
    display:inline-block; margin-top:20px; padding:6px 12px;
    background:rgba(144,238,144,0.1); border:1px solid rgba(144,238,144,0.3);
    border-radius:6px; color:#90ee90; text-decoration:none;
    font:12px system-ui; transition:all 0.2s ease; cursor:pointer;
  }
  .learn-more-btn:hover {
    background:rgba(144,238,144,0.2); border-color:rgba(144,238,144,0.5);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="help-btn" onclick="showHelp()">?</div>
<div class="modal" id="helpModal" onclick="hideHelp()">
  <div class="modal-content" onclick="event.stopPropagation()">
    <h2>The Bubble Experiment</h2>
    <ul>
      <li>Your bubble is <b style="color:#90ee90">light green</b></li>
<li>When other join, their bubbles are <b style="color:#add8e6">light blue</b></li>
<li>Bubbles grow over time</li>
<li>When they reach a certain size, they rise and... pop</li>
<li>Then a new bubble is created</li>
</ul>

<p>You are watching the bubble; nothing is expected of you.</p>

<p>You can meditate while watching the bubble.</p>

<p>You can think of all the others who are watching their bubbles—and maybe yours.</p>

<p>You are never alone on this page because you still have your bubble.</p>

<p>You can race other bubbles if you want, just like when you were a kid.</p>

<p>You can think that in our fast-moving world, the bubble anchors you to the moment.</p>

<p>You can love the bubble.</p>

<p><em>Your bubble is ephemeral.</em></p>
    
    <a href="https://ghost.baptiste-leterrier.com/a-story-about-bubbles/" target="_blank" class="learn-more-btn">Learn more about bubbles</a>
  </div>
</div>

<script>
// Help modal functions
function showHelp() {
  document.getElementById('helpModal').classList.add('show');
}
function hideHelp() {
  document.getElementById('helpModal').classList.remove('show');
}

(() => {
  const WS_PATH = (location.protocol === 'https:' ? 'wss://' : 'ws://') + "sodapop.coresentry.workers.dev" + '/ws';
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.floor(window.innerWidth  * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---- utilities ----
  const rand = (a,b) => a + Math.random()*(b-a);
  const now = () => performance.now();
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const uuid = () => (crypto.randomUUID ? crypto.randomUUID() :
    ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)));

  // ---- simulation params (tuned for "quick but not too much") ----
  const R_START_MIN = 2.5;      // px
  const R_START_MAX = 5.5;      // px
  const R_POP_THRESHOLD = 6.0;  // px
  const GROWTH_EVERY_MS_MIN = 3000; // minimum 3s between growth
  const GROWTH_EVERY_MS_MAX = 8000; // maximum 8s between growth
  const GROWTH_FACTOR_MIN = 1.005;  // minimum growth per step
  const GROWTH_FACTOR_MAX = 1.025;  // maximum growth per step
  const UPDATE_HZ = 1;          // send to server 1x/sec for stability
  const SEND_INTERVAL = 1000 / UPDATE_HZ;

  // Springy “soda rise” feel
  const RISE_ACCEL = -0.0005;   // px/ms^2 in screen px (scaled by dpr later)
  const RISE_DRAG  = 0.997;     // simple drag
  const HOVER_AMPL = 2;         // px bobbing amplitude near bottom
  const HOVER_FREQ = 0.0025;    // per ms

  // ---- world coords are in device pixels (dpr-scaled) for crispness ----
  function worldW(){ return canvas.width; }
  function worldH(){ return canvas.height; }

  // ---- Bubble class ----
  class Bubble {
    constructor({id, me=false}) {
      this.id = id;
      this.me = me;
      this.reset();
    }
    reset() {
      const w = worldW(), h = worldH();
      // Ensure bubbles have enough space on all screen sizes
      const minMargin = Math.min(w, h) * 0.05; // 5% margin minimum
      const marginX = Math.max(minMargin, w * 0.08);
      const marginY = Math.max(minMargin, h * 0.08);
      
      this.x = rand(marginX, w - marginX);
      this.y = rand(h - marginY, h - marginY * 0.3); // Stay near bottom
      
      // Use logical pixels, not device pixels for radius to avoid DPR issues
      this.r = rand(R_START_MIN, R_START_MAX);
      this.vy = 0;
      this.state = 'rest'; // 'rest' (bottom bob), 'rise'
      this.createdAt = now();
      this.lastGrowthAt = now();
      // Random growth parameters for this bubble
      this.growthInterval = rand(GROWTH_EVERY_MS_MIN, GROWTH_EVERY_MS_MAX);
      this.growthFactor = rand(GROWTH_FACTOR_MIN, GROWTH_FACTOR_MAX);
      this.color = this.me ? '#90ee90' : '#add8e6'; // lightgreen vs lightblue
    }
    ensureInBounds() {
      const drawR = this.r * dpr;
      this.x = clamp(this.x, drawR, worldW()-drawR);
      this.y = clamp(this.y, drawR, worldH()-drawR);
    }
    grow(t) {
      if (t - this.lastGrowthAt >= this.growthInterval) {
        const steps = Math.floor((t - this.lastGrowthAt)/this.growthInterval);
        for (let i=0;i<steps;i++) this.r *= this.growthFactor;
        this.lastGrowthAt += steps*this.growthInterval;
      }
    }
    update(dt, t) {
      this.grow(t);

      if (this.state === 'rest') {
        // gentle bobbing
        const bob = Math.sin(t * HOVER_FREQ + this.x*0.001) * HOVER_AMPL * dpr;
        this.y = Math.max(this.y + (bob*0.02), 0.90*worldH());
        if (this.r >= R_POP_THRESHOLD) this.state = 'rise';
      } else if (this.state === 'rise') {
        this.vy += RISE_ACCEL * dt * dpr * (1 + (this.r/8));
        this.vy *= Math.pow(RISE_DRAG, dt);
        this.y += this.vy * dt;
        if (this.y <= this.r * dpr) {
          this.state = 'pop';
          this.popStart = t;
        }
      } else if (this.state === 'pop') {
        // simple fade-out + shrink over 500ms
        const elapsed = t - this.popStart;
        const POP_DURATION = 500;
        this.r *= 0.98; // slower shrink
        const alpha = Math.max(0, 1 - elapsed/POP_DURATION);
        this.color = this.me ? `rgba(144,238,144,${alpha})` : `rgba(173,216,230,${alpha})`;
        if (elapsed >= POP_DURATION) this.reset();
      }
      this.ensureInBounds();
    }
    draw(ctx) {
      // Convert logical radius to device pixels for drawing
      const drawR = this.r * dpr;
      ctx.beginPath();
      ctx.arc(this.x, this.y, drawR, 0, Math.PI*2);
      ctx.fillStyle = this.color;
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 1;
      // subtle highlight
      ctx.beginPath();
      ctx.arc(this.x - drawR*0.35, this.y - drawR*0.35, drawR*0.25, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fill();
    }
    serialize(t) {
      return {
        id: this.id, x:this.x, y:this.y, r:this.r, vy:this.vy,
        state:this.state, lastGrowthAt:this.lastGrowthAt, 
        growthInterval:this.growthInterval, growthFactor:this.growthFactor, t
      };
    }
    applyRemote(state) {
      // Only sync size and critical state, not position to avoid jitter
      const lerp = (a,b,s)=>a+(b-a)*s;
      
      // Sync size and growth parameters for consistency
      this.r = lerp(this.r, state.r, 0.3);
      this.lastGrowthAt = state.lastGrowthAt || this.lastGrowthAt;
      this.growthInterval = state.growthInterval || this.growthInterval;
      this.growthFactor = state.growthFactor || this.growthFactor;
      
      // Force state changes for critical transitions
      if (state.state !== this.state) {
        if (state.state === 'rise' && this.state === 'rest') {
          this.state = 'rise';
          this.vy = 0; // Reset velocity for consistent rise
        } else if (state.state === 'pop') {
          this.state = 'pop';
          this.popStart = now();
        } else if (state.state === 'rest' && this.state === 'pop') {
          this.reset(); // Sync reset after pop
        }
      }
    }
  }

  // ---- My bubble ----
  const myId = uuid();
  const me = new Bubble({id: myId, me: true});

  // ---- Others ----
  const others = new Map(); // id -> Bubble

  // ---- Realtime (WebSocket via Durable Object) ----
  let ws = null, wsOpen = false, lastSend = 0, reconnectTimer = null;

  function connect() {
    try {
      ws = new WebSocket(WS_PATH);
      ws.binaryType = 'arraybuffer';
      ws.onopen = () => {
        wsOpen = true;
        ws.send(JSON.stringify({type:'hello', id:myId, ua:navigator.userAgent, w:worldW(), h:worldH()}));
      };
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'ping') {
            // Respond to server ping to keep connection alive
            return;
          } else if (msg.type === 'state' && Array.isArray(msg.clients)) {
            for (const st of msg.clients) {
              if (!st || !st.id || st.id === myId) continue;
              let b = others.get(st.id);
              if (!b) { 
                b = new Bubble({id:st.id, me:false}); 
                others.set(st.id,b); 
              }
              b.applyRemote(st);
            }
          } else if (msg.type === 'goodbye' && msg.id) {
            others.delete(msg.id);
          }
        } catch(e) {
          console.warn('WebSocket message error:', e);
        }
      };
      ws.onclose = () => scheduleReconnect();
      ws.onerror = () => { try { ws.close(); } catch {} };
    } catch {
      scheduleReconnect();
    }
  }
  function scheduleReconnect() {
    wsOpen = false;
    if (reconnectTimer) return;
    // Exponential backoff with jitter for reconnection
    const delay = Math.min(5000, 1000 + Math.random()*2000);
    reconnectTimer = setTimeout(() => { 
      reconnectTimer = null; 
      console.log('Attempting to reconnect WebSocket...');
      connect(); 
    }, delay);
  }
  connect();

  // ---- Main loop ----
  let lastT = now();
  function frame() {
    const t = now();
    const dt = Math.max(1, Math.min(40, t - lastT)); // clamp for stability
    lastT = t;

    // update local bubble
    me.update(dt, t);

    // send state occasionally
    if (wsOpen && (t - lastSend >= SEND_INTERVAL)) {
      lastSend = t;
      try { ws.send(JSON.stringify({type:'update', id: myId, state: me.serialize(t)})); } catch {}
    }

    // draw
    ctx.clearRect(0,0,worldW(),worldH());
    // draw gentle vignette background bubbles (optional flair)
    // (kept minimal to stay performant; main focus is live bubbles)
    // draw others then me to ensure yours remains visually on top
    for (const b of others.values()) b.update(dt, t), b.draw(ctx);
    me.draw(ctx);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
