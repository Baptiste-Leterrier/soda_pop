<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
<title>Soda Pop Bubbles</title>
<style>
  html, body { height:100%; margin:0; background:#0b0f14; overflow:hidden; touch-action:none; }
  canvas { display:block; width:100vw; height:100vh; }
  .hud {
    position:fixed; left:8px; bottom:8px; padding:4px 8px;
    font:10px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    color:#a0b3c6; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    border-radius:6px; user-select:none; pointer-events:none;
  }
  .hud b { color:#e6f4ff }
  @media (min-width: 600px) {
    .hud { 
      left:12px; bottom:12px; padding:6px 10px; 
      font-size:12px; line-height:1.3; border-radius:8px;
    }
  }
  
  .help-btn {
    position:fixed; top:8px; right:8px; width:28px; height:28px;
    background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2);
    border-radius:50%; cursor:pointer; display:flex; align-items:center; justify-content:center;
    font:bold 12px system-ui; color:white; user-select:none;
    transition:background 0.2s ease;
  }
  .help-btn:hover { background:rgba(255,255,255,0.2); }
  @media (min-width: 600px) {
    .help-btn { top:12px; right:12px; width:32px; height:32px; font-size:14px; }
  }
  
  .modal {
    position:fixed; top:0; left:0; width:100vw; height:100vh;
    background:rgba(0,0,0,0.7); display:none; align-items:flex-start; justify-content:center;
    z-index:1000; overflow-y:auto; padding:20px 0;
  }
  .modal.show { display:flex; }
  
  .modal-content {
    max-width:500px; width:calc(100vw - 40px); margin:0 20px; padding:20px;
    background:#1a1f2b; border:1px solid #2a3441; border-radius:12px; 
    color:#e6f4ff; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    box-shadow:0 20px 40px rgba(0,0,0,0.5); max-height:calc(100vh - 80px); overflow-y:auto;
    position:relative;
  }
  
  @media (min-width: 600px) {
    .modal { align-items:center; padding:40px 0; }
    .modal-content { 
      font-size:16px; line-height:1.5; padding:30px; 
      width:auto; margin:20px; max-height:calc(100vh - 120px);
    }
  }
  .modal-content h2 {
    margin:0 0 15px 0; color:#90ee90; font-size:18px; font-weight:normal;
  }
  @media (min-width: 600px) {
    .modal-content h2 { font-size:20px; margin-bottom:20px; }
  }
  .modal-content ul {
    margin:0; padding-left:20px; color:#a0b3c6;
  }
  .modal-content li { margin:8px 0; }
  .modal-content p {
    margin:12px 0; color:#c0d0e0; font-style:italic;
  }
  @media (min-width: 600px) {
    .modal-content p { margin:15px 0; }
  }
  .learn-more-btn {
    display:inline-block; margin-top:20px; padding:6px 12px;
    background:rgba(144,238,144,0.1); border:1px solid rgba(144,238,144,0.3);
    border-radius:6px; color:#90ee90; text-decoration:none;
    font:12px system-ui; transition:all 0.2s ease; cursor:pointer;
  }
  .learn-more-btn:hover {
    background:rgba(144,238,144,0.2); border-color:rgba(144,238,144,0.5);
  }
  .modal-close {
    position:absolute; top:10px; right:10px; width:24px; height:24px;
    background:none; border:none; color:#a0b3c6; cursor:pointer;
    display:flex; align-items:center; justify-content:center;
    font:bold 16px system-ui; line-height:1; transition:color 0.2s ease;
  }
  .modal-close:hover { color:#e6f4ff; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="help-btn" onclick="showHelp()">?</div>
<div class="modal" id="helpModal" onclick="hideHelp()">
  <div class="modal-content" onclick="event.stopPropagation()">
    <button class="modal-close" onclick="hideHelp()">&times;</button>
    <h2>The Bubble Experiment</h2>
    <ul>
      <li>Your bubble is <b style="color:#90ee90">light green</b></li>
<li>When other join, their bubbles are <b style="color:#add8e6">light blue</b></li>
<li>Bubbles grow over time</li>
<li>When they reach a certain size, they rise and... pop</li>
<li>Then a new bubble is created</li>
</ul>

<p>You are watching the bubble; nothing is expected of you.</p>

<p>You can meditate while watching the bubble.</p>

<p>You can think of all the others who are watching their bubbles—and maybe yours.</p>

<p>You are never alone on this page because you still have your bubble.</p>

<p>You can race other bubbles if you want, just like when you were a kid.</p>

<p>You can think that in our fast-moving world, the bubble anchors you to the moment.</p>

<p>You can love the bubble.</p>

<p><em>Your bubble is ephemeral.</em></p>
    
    <a href="https://ghost.baptiste-leterrier.com/a-story-about-bubbles/" target="_blank" class="learn-more-btn">Learn more about bubbles</a>
  </div>
</div>

<script>
// Help modal functions
function showHelp() {
  document.getElementById('helpModal').classList.add('show');
}
function hideHelp() {
  document.getElementById('helpModal').classList.remove('show');
}

(() => {
  // ---- iOS/Safari compatibility detection (must be first) ----
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

  const WS_PATH = (location.protocol === 'https:' ? 'wss://' : 'ws://') + "sodapop.coresentry.workers.dev" + '/ws';
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    // iOS Safari DPR handling
    if (isIOS && isSafari) {
      // iOS Safari sometimes reports incorrect DPR, clamp it
      dpr = Math.min(3, Math.max(1, window.devicePixelRatio || 1));
    } else {
      dpr = Math.max(1, window.devicePixelRatio || 1);
    }
    
    const w = Math.floor(window.innerWidth * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; 
      canvas.height = h;
      
      // iOS Safari requires explicit style setting
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      
      // Force context reset on iOS to avoid rendering issues
      if (isIOS) {
        const currentFillStyle = ctx.fillStyle;
        ctx.fillStyle = currentFillStyle;
      }
    }
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();
  
  // ---- utilities ----
  const rand = (a,b) => a + Math.random()*(b-a);
  const now = () => {
    if (typeof performance !== 'undefined' && performance.now) {
      return performance.now();
    }
    return Date.now();
  };
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  
  // iOS-compatible UUID generation
  const uuid = () => {
    if (typeof crypto !== 'undefined' && crypto.randomUUID) {
      try {
        return crypto.randomUUID();
      } catch (e) {
        console.warn('crypto.randomUUID failed, using fallback');
      }
    }
    // Fallback UUID generation for iOS Safari
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c == 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  };

  // ---- simulation params (tuned for "quick but not too much") ----
  const R_START_MIN = 2.5;      // px
  const R_START_MAX = 5.5;      // px
  const R_POP_THRESHOLD = 6.0;  // px
  const GROWTH_EVERY_MS_MIN = 3000; // minimum 3s between growth
  const GROWTH_EVERY_MS_MAX = 8000; // maximum 8s between growth
  const GROWTH_FACTOR_MIN = 1.005;  // minimum growth per step
  const GROWTH_FACTOR_MAX = 1.025;  // maximum growth per step
  const UPDATE_HZ = 1;          // send to server 1x/sec for stability
  const SEND_INTERVAL = 1000 / UPDATE_HZ;

  // Springy “soda rise” feel
  const RISE_ACCEL = -0.0005;   // px/ms^2 in screen px (scaled by dpr later)
  const RISE_DRAG  = 0.997;     // simple drag
  const HOVER_AMPL = 2;         // px bobbing amplitude near bottom
  const HOVER_FREQ = 0.0025;    // per ms

  // ---- world coords are in device pixels (dpr-scaled) for crispness ----
  function worldW(){ return canvas.width; }
  function worldH(){ return canvas.height; }

  // ---- Bubble class ----
  class Bubble {
    constructor({id, me=false}) {
      this.id = id;
      this.me = me;
      this.reset();
    }
    reset() {
      const w = worldW(), h = worldH();
      // Ensure bubbles have enough space on all screen sizes
      const minMargin = Math.min(w, h) * 0.05; // 5% margin minimum
      const marginX = Math.max(minMargin, w * 0.08);
      const marginY = Math.max(minMargin, h * 0.08);
      
      this.x = rand(marginX, w - marginX);
      this.y = rand(h - marginY, h - marginY * 0.3); // Stay near bottom
      
      // Use logical pixels, not device pixels for radius to avoid DPR issues
      this.r = rand(R_START_MIN, R_START_MAX);
      this.vy = 0;
      this.state = 'rest'; // 'rest' (bottom bob), 'rise'
      this.createdAt = now();
      this.lastGrowthAt = now();
      // Random growth parameters for this bubble
      this.growthInterval = rand(GROWTH_EVERY_MS_MIN, GROWTH_EVERY_MS_MAX);
      this.growthFactor = rand(GROWTH_FACTOR_MIN, GROWTH_FACTOR_MAX);
      this.color = this.me ? '#90ee90' : '#add8e6'; // lightgreen vs lightblue
    }
    ensureInBounds() {
      const drawR = this.r * dpr;
      this.x = clamp(this.x, drawR, worldW()-drawR);
      this.y = clamp(this.y, drawR, worldH()-drawR);
    }
    grow(t) {
      if (t - this.lastGrowthAt >= this.growthInterval) {
        const steps = Math.floor((t - this.lastGrowthAt)/this.growthInterval);
        for (let i=0;i<steps;i++) this.r *= this.growthFactor;
        this.lastGrowthAt += steps*this.growthInterval;
      }
    }
    update(dt, t) {
      this.grow(t);

      if (this.state === 'rest') {
        // gentle bobbing
        const bob = Math.sin(t * HOVER_FREQ + this.x*0.001) * HOVER_AMPL * dpr;
        this.y = Math.max(this.y + (bob*0.02), 0.90*worldH());
        if (this.r >= R_POP_THRESHOLD) this.state = 'rise';
      } else if (this.state === 'rise') {
        this.vy += RISE_ACCEL * dt * dpr * (1 + (this.r/8));
        // Replace Math.pow with faster operation for iOS performance
        const dragFactor = Math.exp(Math.log(RISE_DRAG) * dt);
        this.vy *= dragFactor;
        this.y += this.vy * dt;
        if (this.y <= this.r * dpr) {
          this.state = 'pop';
          this.popStart = t;
        }
      } else if (this.state === 'pop') {
        // simple fade-out + shrink over 500ms
        const elapsed = t - this.popStart;
        const POP_DURATION = 500;
        this.r *= 0.98; // slower shrink
        const alpha = Math.max(0, 1 - elapsed/POP_DURATION);
        this.color = this.me ? `rgba(144,238,144,${alpha})` : `rgba(173,216,230,${alpha})`;
        if (elapsed >= POP_DURATION) this.reset();
      }
      this.ensureInBounds();
    }
    draw(ctx) {
      // Convert logical radius to device pixels for drawing
      const drawR = this.r * dpr;
      
      // Main bubble - use rgba for iOS compatibility instead of globalAlpha
      ctx.beginPath();
      ctx.arc(this.x, this.y, drawR, 0, Math.PI*2);
      
      // Extract alpha from color if it's rgba, otherwise use 0.9
      let bubbleColor = this.color;
      if (typeof this.color === 'string' && !this.color.startsWith('rgba')) {
        // Convert hex/named colors to rgba with 0.9 opacity for iOS
        if (this.color === '#90ee90') {
          bubbleColor = 'rgba(144,238,144,0.9)';
        } else if (this.color === '#add8e6') {
          bubbleColor = 'rgba(173,216,230,0.9)';
        } else {
          bubbleColor = this.color; // Keep rgba colors as-is
        }
      }
      
      ctx.fillStyle = bubbleColor;
      ctx.fill();
      
      // Subtle highlight - simplified for iOS performance
      if (drawR > 3) { // Only draw highlight for larger bubbles
        ctx.beginPath();
        ctx.arc(this.x - drawR*0.35, this.y - drawR*0.35, Math.max(1, drawR*0.25), 0, Math.PI*2);
        ctx.fillStyle = 'rgba(255,255,255,0.35)';
        ctx.fill();
      }
    }
    serialize(t) {
      return {
        id: this.id, x:this.x, y:this.y, r:this.r, vy:this.vy,
        state:this.state, lastGrowthAt:this.lastGrowthAt, 
        growthInterval:this.growthInterval, growthFactor:this.growthFactor, t
      };
    }
    applyRemote(state) {
      // Only sync size and critical state, not position to avoid jitter
      const lerp = (a,b,s)=>a+(b-a)*s;
      
      // Sync size and growth parameters for consistency
      this.r = lerp(this.r, state.r, 0.3);
      this.lastGrowthAt = state.lastGrowthAt || this.lastGrowthAt;
      this.growthInterval = state.growthInterval || this.growthInterval;
      this.growthFactor = state.growthFactor || this.growthFactor;
      
      // Force state changes for critical transitions
      if (state.state !== this.state) {
        if (state.state === 'rise' && this.state === 'rest') {
          this.state = 'rise';
          this.vy = 0; // Reset velocity for consistent rise
        } else if (state.state === 'pop') {
          this.state = 'pop';
          this.popStart = now();
        } else if (state.state === 'rest' && this.state === 'pop') {
          this.reset(); // Sync reset after pop
        }
      }
    }
  }

  // ---- My bubble ----
  const myId = uuid();
  const me = new Bubble({id: myId, me: true});

  // ---- Others ----
  const others = new Map(); // id -> Bubble

  // ---- Realtime (WebSocket via Durable Object) ----
  let ws = null, wsOpen = false, lastSend = 0, reconnectTimer = null;

  function connect() {
    try {
      ws = new WebSocket(WS_PATH);
      // Remove binaryType setting for iOS compatibility
      
      ws.onopen = () => {
        wsOpen = true;
        try {
          const helloMsg = {
            type:'hello', 
            id:myId, 
            ua:navigator.userAgent, 
            w:worldW(), 
            h:worldH(),
            ios: isIOS,
            safari: isSafari
          };
          ws.send(JSON.stringify(helloMsg));
        } catch(e) {
          console.warn('Failed to send hello message:', e);
        }
      };
      
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'ping') {
            // Respond to server ping to keep connection alive
            return;
          } else if (msg.type === 'state' && Array.isArray(msg.clients)) {
            for (const st of msg.clients) {
              if (!st || !st.id || st.id === myId) continue;
              let b = others.get(st.id);
              if (!b) { 
                b = new Bubble({id:st.id, me:false}); 
                others.set(st.id,b); 
              }
              b.applyRemote(st);
            }
          } else if (msg.type === 'goodbye' && msg.id) {
            others.delete(msg.id);
          }
        } catch(e) {
          console.warn('WebSocket message error:', e);
        }
      };
      
      ws.onclose = (event) => {
        wsOpen = false;
        console.log('WebSocket closed:', event.code, event.reason);
        scheduleReconnect();
      };
      
      ws.onerror = (error) => { 
        console.warn('WebSocket error:', error);
        try { ws.close(); } catch {} 
      };
    } catch(e) {
      console.warn('Failed to create WebSocket:', e);
      scheduleReconnect();
    }
  }
  function scheduleReconnect() {
    wsOpen = false;
    if (reconnectTimer) return;
    // Exponential backoff with jitter for reconnection
    const delay = Math.min(5000, 1000 + Math.random()*2000);
    reconnectTimer = setTimeout(() => { 
      reconnectTimer = null; 
      console.log('Attempting to reconnect WebSocket...');
      connect(); 
    }, delay);
  }
  connect();

  // ---- Main loop ----
  let lastT = now();
  let frameCount = 0;
  
  function frame() {
    try {
      const t = now();
      const dt = Math.max(1, Math.min(40, t - lastT)); // clamp for stability
      lastT = t;
      frameCount++;

      // update local bubble
      me.update(dt, t);

      // send state occasionally
      if (wsOpen && (t - lastSend >= SEND_INTERVAL)) {
        lastSend = t;
        try { 
          ws.send(JSON.stringify({type:'update', id: myId, state: me.serialize(t)})); 
        } catch(e) {
          console.warn('Failed to send WebSocket update:', e);
          wsOpen = false;
        }
      }

      // draw - with iOS optimizations
      const w = worldW();
      const h = worldH();
      
      // Clear canvas - use fillRect on iOS for better performance
      if (isIOS) {
        ctx.fillStyle = '#0b0f14';
        ctx.fillRect(0, 0, w, h);
      } else {
        ctx.clearRect(0, 0, w, h);
      }
      
      // draw others then me to ensure yours remains visually on top
      for (const b of others.values()) {
        b.update(dt, t);
        b.draw(ctx);
      }
      me.draw(ctx);

      requestAnimationFrame(frame);
      
    } catch(e) {
      console.error('Animation frame error:', e);
      // Try to recover by restarting the animation loop
      setTimeout(() => requestAnimationFrame(frame), 100);
    }
  }
  
  // Add visibility change handling for iOS Safari
  document.addEventListener('visibilitychange', () => {
    if (!document.hidden) {
      // Reset timing when returning to tab to avoid jumps
      lastT = now();
    }
  });
  
  // iOS Safari memory management
  if (isIOS) {
    // Handle page visibility and memory pressure
    window.addEventListener('pagehide', () => {
      if (ws) {
        try { ws.close(); } catch {}
      }
    });
    
    window.addEventListener('pageshow', () => {
      if (!wsOpen && !reconnectTimer) {
        setTimeout(connect, 1000);
      }
    });
  }
  
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
