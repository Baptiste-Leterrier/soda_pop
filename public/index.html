<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Soda Pop Bubbles</title>
<style>
  html, body { height:100%; margin:0; background:#0b0f14; overflow:hidden; }
  canvas { display:block; width:100vw; height:100vh; }
  .hud {
    position:fixed; left:12px; bottom:12px; padding:6px 10px;
    font:12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    color:#a0b3c6; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.06);
    border-radius:8px; user-select:none; pointer-events:none;
  }
  .hud b { color:#e6f4ff }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">you = <b style="color:#90ee90">light green</b>, others = <b style="color:#add8e6">light blue</b></div>

<script>
(() => {
  const WS_PATH = (location.protocol === 'https:' ? 'wss://' : 'ws://') + "sodapop.coresentry.workers.dev" + '/ws';
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let dpr = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.floor(window.innerWidth  * dpr);
    const h = Math.floor(window.innerHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---- utilities ----
  const rand = (a,b) => a + Math.random()*(b-a);
  const now = () => performance.now();
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const uuid = () => (crypto.randomUUID ? crypto.randomUUID() :
    ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16)));

  // ---- simulation params (tuned for “quick but not too much”) ----
  const R_START_MIN = 2.5;      // px
  const R_START_MAX = 5.5;      // px
  const R_POP_THRESHOLD = 6.0;  // px
  const GROWTH_EVERY_MS = 5000; // +1% every 5s
  const GROWTH_FACTOR = 1.01;   // multiplicative
  const UPDATE_HZ = 5;          // send to server 5x/sec
  const SEND_INTERVAL = 1000 / UPDATE_HZ;

  // Springy “soda rise” feel
  const RISE_ACCEL = -0.0005;   // px/ms^2 in screen px (scaled by dpr later)
  const RISE_DRAG  = 0.997;     // simple drag
  const HOVER_AMPL = 2;         // px bobbing amplitude near bottom
  const HOVER_FREQ = 0.0025;    // per ms

  // ---- world coords are in device pixels (dpr-scaled) for crispness ----
  function worldW(){ return canvas.width; }
  function worldH(){ return canvas.height; }

  // ---- Bubble class ----
  class Bubble {
    constructor({id, me=false}) {
      this.id = id;
      this.me = me;
      this.reset();
    }
    reset() {
      const w = worldW(), h = worldH();
      this.x = rand(0.08*w, 0.92*w);
      this.y = rand(0.90*h, 0.98*h);
      this.r = rand(R_START_MIN, R_START_MAX)*dpr;
      this.vy = 0;
      this.state = 'rest'; // 'rest' (bottom bob), 'rise'
      this.createdAt = now();
      this.lastGrowthAt = now();
      this.color = this.me ? '#90ee90' : '#add8e6'; // lightgreen vs lightblue
    }
    ensureInBounds() {
      this.x = clamp(this.x, this.r, worldW()-this.r);
      this.y = clamp(this.y, this.r, worldH()-this.r);
    }
    grow(t) {
      if (t - this.lastGrowthAt >= GROWTH_EVERY_MS) {
        const steps = Math.floor((t - this.lastGrowthAt)/GROWTH_EVERY_MS);
        for (let i=0;i<steps;i++) this.r *= GROWTH_FACTOR;
        this.lastGrowthAt += steps*GROWTH_EVERY_MS;
      }
    }
    update(dt, t) {
      this.grow(t);

      if (this.state === 'rest') {
        // gentle bobbing
        const bob = Math.sin(t * HOVER_FREQ + this.x*0.001) * HOVER_AMPL * dpr;
        this.y = Math.max(this.y + (bob*0.02), 0.90*worldH());
        if (this.r/dpr >= R_POP_THRESHOLD) this.state = 'rise';
      } else if (this.state === 'rise') {
        this.vy += RISE_ACCEL * dt * dpr * (1 + (this.r/(8*dpr))); // slightly faster with size
        this.vy *= Math.pow(RISE_DRAG, dt);
        this.y += this.vy * dt;
        if (this.y <= -this.r) this.reset(); // pop and immediately respawn
      }
      this.ensureInBounds();
    }
    draw(ctx) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
      ctx.fillStyle = this.color;
      ctx.globalAlpha = 0.9;
      ctx.fill();
      ctx.globalAlpha = 1;
      // subtle highlight
      ctx.beginPath();
      ctx.arc(this.x - this.r*0.35, this.y - this.r*0.35, this.r*0.25, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,0.35)';
      ctx.fill();
    }
    serialize(t) {
      return {
        id: this.id, x:this.x, y:this.y, r:this.r, vy:this.vy,
        state:this.state, lastGrowthAt:this.lastGrowthAt, t
      };
    }
    applyRemote(state) {
      // Snap toward remote state, then let local physics continue for fluidity
      const lerp = (a,b,s)=>a+(b-a)*s;
      const s = 0.35;
      this.x = lerp(this.x, state.x, s);
      this.y = lerp(this.y, state.y, s);
      this.r = lerp(this.r, state.r, s);
      this.vy = lerp(this.vy, state.vy ?? this.vy, s);
      this.state = state.state || this.state;
      this.lastGrowthAt = state.lastGrowthAt || this.lastGrowthAt;
    }
  }

  // ---- My bubble ----
  const myId = uuid();
  const me = new Bubble({id: myId, me: true});

  // ---- Others ----
  const others = new Map(); // id -> Bubble

  // ---- Realtime (WebSocket via Durable Object) ----
  let ws = null, wsOpen = false, lastSend = 0, reconnectTimer = null;

  function connect() {
    try {
      ws = new WebSocket(WS_PATH);
      ws.binaryType = 'arraybuffer';
      ws.onopen = () => {
        wsOpen = true;
        ws.send(JSON.stringify({type:'hello', id:myId, ua:navigator.userAgent, w:worldW(), h:worldH()}));
      };
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'state' && Array.isArray(msg.clients)) {
            for (const st of msg.clients) {
              if (!st || !st.id || st.id === myId) continue;
              let b = others.get(st.id);
              if (!b) { b = new Bubble({id:st.id, me:false}); others.set(st.id,b); }
              b.applyRemote(st);
            }
          } else if (msg.type === 'goodbye' && msg.id) {
            others.delete(msg.id);
          }
        } catch {}
      };
      ws.onclose = () => scheduleReconnect();
      ws.onerror = () => { try { ws.close(); } catch {} };
    } catch {
      scheduleReconnect();
    }
  }
  function scheduleReconnect() {
    wsOpen = false;
    if (reconnectTimer) return;
    reconnectTimer = setTimeout(() => { reconnectTimer = null; connect(); }, 1000 + Math.random()*1000);
  }
  connect();

  // ---- Main loop ----
  let lastT = now();
  function frame() {
    const t = now();
    const dt = Math.max(1, Math.min(40, t - lastT)); // clamp for stability
    lastT = t;

    // update local bubble
    me.update(dt, t);

    // send state occasionally
    if (wsOpen && (t - lastSend >= SEND_INTERVAL)) {
      lastSend = t;
      try { ws.send(JSON.stringify({type:'update', id: myId, state: me.serialize(t)})); } catch {}
    }

    // draw
    ctx.clearRect(0,0,worldW(),worldH());
    // draw gentle vignette background bubbles (optional flair)
    // (kept minimal to stay performant; main focus is live bubbles)
    // draw others then me to ensure yours remains visually on top
    for (const b of others.values()) b.update(dt, t), b.draw(ctx);
    me.draw(ctx);

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
